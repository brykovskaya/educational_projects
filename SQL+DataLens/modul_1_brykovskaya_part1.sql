--Проект "Данные о жилой недвижимости Спб и области"
--Вводные данные: Агентство недвижимости из Петрозаводска планирует выйти на рынок Санкт-Петербурга и Ленинградской области
--и перевести основный офис в новый регион.
--Цель проекта: получить данные, которые помогут заказчику спланировать бизнес-стратегию,
--выбрать сегмент недвижимости с высоким спросом и подходящий сезон для публикации объявлений.
--Задачи:
--изучить архивную информацию сервиса Яндекс Недвижимость: объявления о продаже жилой недвижимости в Санкт-Петербурге
--и Ленинградской области за несколько лет, чтобы найти самые перспективные сегменты недвижимости
--и доработать дашборд, добавить новые элементы с учетом полученных данных
--ПЛАН:
--1.Разведочный анализ данных
--2. Поиск ответов на ad hoc задачи с помощью SQL-запросов:
--2.1.Определить наиболее привлекательные сегменты недвижимости Санкт-Петербурга и городов Ленинградской области,вности объявлений.
--2.2.Понять сезонные тенденции на рынке Санкт-Петербурга и городов Ленинградской области,
--чтобы знать периоды с повышенной активностью продавцов и покупателей недвижимости в регионе.
--Это поможет спланировать маркетинговые кампании и выбрать сроки для выхода на рынок.
--2.3.Выяснить, в каких населённых пунктах Ленинградской области активнее всего продаётся недвижимость и какая именно,
--чтобы знать перспективные районы.
--3.Доработка дашборда
-- Автор: Брыковская Наталья
-- Дата:  05.10.2024
--1.Разведочный анализ данных
--1.1.Информация о таблицах.
--Выведем названия всех таблиц схемы
SELECT
	table_name
FROM
	information_schema.tables
WHERE
	table_schema = 'real_estate';

--1.2. Данные в таблицах.
--Схема real_estate содержит таблицы advertisement, city, flats , type   Изучим их.
--Получим информацию о названии полей таблиц и типе данных в них. Итоговая таблица будет содержать такие поля:
--	table_schema — название схемы;
--	table_name — название таблицы;
--	column_name — название поля;
--	data_type — тип данных, которые хранятся в поле;
--	constraint_name — информация о первичном или внешнем ключе. Поле может содержать значения NULL — это значит,
--то поле не имеет ограничений и не используется в качестве первичного или внешнего ключа.
SELECT
	c.table_schema,	-- название схемы
	c.table_name,	-- название таблицы
	c.column_name,	-- название поля
	c.data_type,	-- тип данных, которые хранятся в поле
	constraint_name	-- ключи
FROM
	information_schema.columns AS c
LEFT JOIN (
	SELECT
		table_name,
		column_name,
		constraint_name
	FROM
		information_schema.key_column_usage
	WHERE
		(table_name = 'advertisement'
			OR table_name = 'city'
			OR table_name = 'flats'
			OR table_name = 'type'
   )
		AND table_schema = 'real_estate'
) AS k ON
	k.column_name = c.column_name
WHERE
	table_schema = 'real_estate'
ORDER BY
	table_name, column_name;

--1.3. Таблица advertisement: обзор, пропуски, дубликаты
--1.3.1 Теперь познакомьтесь с данными и выведем первые 5 строк таблицы
SELECT 	*
FROM real_estate.advertisement
LIMIT 5;
--1.3.2 оценим полноту данных 
-- Всего данные содержат информацию о 23650 объявлениях,
--в 13% от всех объявлениях содержится пропуски в строке days_exposition
SELECT
	строк_таблицы,									-- количество строк/объявлений в таблице													
	строк_таблицы - строк_первого_дня AS null_first_day_exposition,  			-- количество пропусков first_day_exposition
	строк_таблицы - строк_объявлений AS null_id,					-- количество пропусков id
	строк_таблицы - строк_дней_экспозиции AS null_days_exposition,                                 -- количество пропусков days_exposition
	ROUND((строк_таблицы - строк_дней_экспозиции)::NUMERIC / строк_таблицы,
	2)AS part_null_days_exposition,								-- доля пропусков days_exposition
	строк_таблицы - строк_цены AS null_last_price                                                                 -- количество пропусков last_price
FROM
	(
	SELECT 										--в подзапросе получим оконными функциями данные по всем полям
		COUNT(*) OVER () AS строк_таблицы,
		COUNT(first_day_exposition) OVER () AS строк_первого_дня,
		COUNT(id) OVER () AS строк_объявлений,
		COUNT(days_exposition) OVER () AS строк_дней_экспозиции,
		COUNT(last_price) OVER () AS строк_цены
	FROM
		real_estate.advertisement
	LIMIT 1) AS t;		
	
--1.3.3 проверим строки на полные дубликаты
--В таблице advertisement нет дубликатов, так как в столбце id нет дублей -а это идентификатор объявения- первичный ключ.

SELECT * 
FROM (
	SELECT 
		id,
		COUNT(*) OVER (PARTITION BY id) as дубли_id
	FROM real_estate.advertisement
	) AS t
WHERE дубли_id > 1;

--1.3.4 детальнее посмотрим на данные по пропускам. Пропуска в днях нахождения объявления на сайте - значит что объявление актуально.
--каких годах размещено объявление и какое их количество:
-- больше активных объявлений в  Что выглядит логичным. А вот объявления, размещенные несколько лет
-- это возможные претенденты на ошибочно не снятые с продажи.
SELECT
	EXTRACT(YEAR FROM first_day_exposition::date) AS first_year_exposition,	     	-- год размещения объявления
	COUNT(first_day_exposition) AS activ_id_by_year,				-- количество активных/не закрытых объявлений по году
	total_activ_id,
	ROUND(COUNT(first_day_exposition)::NUMERIC / total_activ_id,
	3) AS part_activ_id         									-- доля активных объявлений от общей числа активных об.
FROM
	(
	SELECT
		first_day_exposition,
		COUNT(first_day_exposition) OVER () AS total_activ_id		-- количество активных/не закрытых объявлений всего
	FROM
		real_estate.advertisement
	WHERE
		days_exposition IS NULL
	) AS t
GROUP BY
	first_year_exposition,
	total_activ_id
ORDER BY first_year_exposition;
--1.3.5 Посмотрим за какой период представлены объявления о продаже недвижимости. 
--Выберем диапазон значений — минимальную и максимальную даты подачи объявленний.
--Объявления представлены за период с 27.11.2014 по 03.05.2019.
--данные за 2014 и 2019 годы — неполные: за 2014 год данные начинаются с конца ноября, а за 2019 — заканчиваются в мае. 
--Если понадобится изучить годовую динамику параметров, выбираем только полные годы: 
--2015, 2016, 2017, 2018.
SELECT 
	MIN(first_day_exposition) AS min_first_day_exposition,
	MAX(first_day_exposition) AS max_first_day_exposition
FROM
	real_estate.advertisement

--1.4. Таблица type: обзор, пропуски, дубликаты
--1.4.1 Познакомьтесь с данными и выведем первые 5 строк таблицы
SELECT 	*
FROM real_estate.TYPE
LIMIT 5;
--1.4.2 оценим полноту данных
-- Всего данные содержат информацию о 10 типах названий населенных пунктов
--в 13% от всех объявлениях содержится пропуски в строке days_exposition
SELECT
	строк_таблицы,											-- количество строк в таблице													
	строк_таблицы-строк_type_id AS null_type_id, 			-- количество пропусков
	строк_таблицы-строк_названий AS null_type               -- количество пропусков
FROM
	(
	SELECT 		        -- в подзапросе получим оконными функциями данные по всем полям
		COUNT(*) OVER () AS строк_таблицы,
		COUNT(type_id) OVER () AS строк_type_id,
		COUNT(type) OVER () AS строк_названий
	FROM
		real_estate.type
	LIMIT 1) AS t;		-- ограничим вывод одной строкой, в которой получены оконными функциями данные по полям
--1.4.3 проверим строки на полные дубликаты
--В таблице type нет дубликатов, так как в столбце type_id нет дублей -а это идентификатор объявления- первичный ключ.
SELECT *
FROM (
	SELECT 
		type_id,
		COUNT(*) OVER (PARTITION BY type_id) as дубли_type_id
	FROM 
		real_estate.type) AS t
WHERE дубли_type_id > 1;
--1.4.4 Выведем все уникальные значения названий, поищем повторения в названиях населенных пунктов
--все названия уникальные, повторений нет
SELECT
	type AS название_типа_нп,
	COUNT(type) AS количество_повторений,
	COUNT(type) OVER () AS всего_названий_типов_нп
FROM real_estate.TYPE
GROUP BY название_типа_нп;
--1.5   Таблица city: обзор, пропуски, дубликаты
--1.5.1 Познакомьтесь с данными и выведем первые 5 строк таблицы
SELECT 	*
FROM real_estate.city
LIMIT 5;


--1.5.2 оценим полноту данных
--таблица содержит 305 названий населенных пунктов, пропусков в строках нет.
SELECT
	строк_таблицы,									       	-- количество строк в таблице													
	строк_таблицы - строк_city_id AS null_строк_city_id,    -- количество пропусков
	строк_таблицы - строк_названий AS null_city             -- количество пропусков
FROM
	(
	SELECT 		        -- в подзапросе получим оконными функциями данные по всем полям
		COUNT(*) OVER () AS строк_таблицы,
		COUNT(city_id) OVER () AS строк_city_id,
		COUNT(city) OVER () AS строк_названий
	FROM
		real_estate.city
	LIMIT 1) -- ограничим вывод одной строкой, в которой получены оконными функциями данные по полям
	AS t;	
--1.5.3 проверим строки на явные дубликаты
SELECT
	city,
	city_id,
	дубли_city,
	дубли_city_id
FROM (
	SELECT
		city,
		city_id,
		COUNT(city) OVER (PARTITION BY city) AS дубли_city,
		COUNT(city_id) OVER (PARTITION BY city_id) AS дубли_city_id
	FROM
		real_estate.city
	ORDER BY
		city
	) AS t
WHERE
	дубли_city > 1
	OR дубли_city_id > 1;

--1.5.4 Выведем все уникальные значения названий населенных пунктов, поищем в названиях населенных пунктов опечатки. Проверим на неполные дубликаты.
-- Названий населенных пунктов 305, наименования не содержат опечаток.
SELECT
	city,
	COUNT(city) OVER() AS всего_названий_городов
FROM
	real_estate.city
GROUP BY
	city
ORDER BY
	city;
--1.5.5.Поищем дубликаты в названиях населенных пунктов и типах населенных пунктов в таблице flats. присоединим к ней названия и типы населенных
--пунктов
WITH cte AS (
SELECT
	city,
	TYPE,
	COUNT(city) OVER (PARTITION BY city) AS дубли
FROM
	real_estate.flats AS f
LEFT JOIN
	real_estate.city AS c ON f.city_id=c.city_id
LEFT JOIN
	real_estate.type AS t ON f.type_id=t.type_id
GROUP BY
	city,
	type
ORDER BY city
)
SELECT
	*
FROM
	cte
WHERE
	дубли >1
ORDER BY
	дубли DESC,
	city;
--1.5.6. выведем уникальные названия населенных пунктов, которые предположительно имеют неявные
--дубликаты в наименовании типа населенных пунктов. Всего городов, имеющих предположительно дубли - 22.
WITH cte AS (
SELECT
	city,
	TYPE,
	COUNT(city) OVER (PARTITION BY city) AS дубли
FROM
	real_estate.flats AS f
LEFT JOIN
	real_estate.city AS c ON f.city_id=c.city_id
LEFT JOIN
	real_estate.type AS t ON f.type_id=t.type_id
GROUP BY
	city,
	type
ORDER BY city
),
cte1 AS (
	SELECT 	*
	FROM
		cte
	WHERE
		дубли >1
	ORDER BY
		дубли DESC,
		city
		)
SELECT
	city,
	дубли,
	COUNT(city) OVER () AS всего_задубл_городов
FROM (
	SELECT city, дубли FROM cte1
	GROUP BY city, дубли
	ORDER BY city
	) AS t;
--1.5.7 Посмотрим как распределяются объявления по типам населённых пунктов.
--Большая часть объявлений содержит информацию о недвижимости в городах 84,6%
SELECT
	type,
	COUNT(type) AS количество_объявлений,
	ROUND(COUNT(type)::NUMERIC / total_id * 100, 3) AS процент_среди_объявлений
FROM (
	SELECT 
		type_id,
		city_id,
		COUNT(id) OVER () AS total_id
	FROM 
		real_estate.flats
	LEFT JOIN
		real_estate.city AS c USING (city_id)
		) AS f
LEFT JOIN
	real_estate.type AS t ON f.type_id=t.type_id
GROUP BY
	TYPE, total_id
ORDER BY количество_объявлений DESC; 
--1.5.8 Посмотрим сколько названий населенных пунктов у каждого типа населенного пункта.
--Садоводческое некоммерческое товарищество содержит всего одно объявление.
--Тип населённого пункта «посёлок» и  «деревня» содержит наибольшее количество различных нименований.
WITH cte AS
( 
	SELECT 
		type, 
		city
	FROM 
		real_estate.flats
	LEFT JOIN
		real_estate.city AS c USING (city_id)
	LEFT JOIN
		real_estate.TYPE AS t USING (type_id)
	GROUP BY 
		city,
		type
)
SELECT 
	type AS тип_нп,
	COUNT(city) AS названий_нп,
	ROUND(COUNT(city)::NUMERIC / всего_названий * 100, 2) AS процент_среди_объявлений
FROM (
	SELECT 
		*, 
		COUNT(city) OVER () AS всего_названий
	FROM 
		cte) AS t
GROUP BY 
	тип_нп,
	всего_названий
ORDER BY названий_нп DESC;	
--Вывод: города лидируют по количеству объявлений: 
--около 85% объявлений приходится на этот тип населённого пункта. 
--Затем идет посёлок — около 9%. 
--Остальные типы населённых пунктов содержат не такое большое количество объявлений в процентном соотношении.
--При изучении характеристик недвижимости именно недвижимость городов определит основные статистические 
--показатели, как наибольшая группа.

--1.6. Исследуем время активности объявлений
--Данные содержат не только время публикации объявления, но и количество дней, в течение которых объявление было активным, 
--то есть доступным для потенциальных покупателей. 
--сли объявления снимали с продажи, в большинстве случаев можно решить, что недвижимость продали. 
--В рамках этого проекта будем считать именно так, поскольку других прямых данных о продажах нет.
--Этот параметр позволяет спрогнозировать среднее время продажи недвижимости.
--Изучим данные более детально.

--1.6.1 Статистики по полю со временем активности объявлений
--Найдем минимальное, максимальное, среднее (округлено до двух знаков после запятой) значения 
--и медиану со временем активности объявлений. 
--Максимальная длительность публикации объявления — более 4 лет, минимальная 1 день, 
--медиана 95 дней и среднее 180.75 дней различаются почти в 2 раза, что может говорить о наличии единичных высоких значений — выбросов. 
--Результаты показывают, что половину объявлений сняли с публикации в течение 95 дней с момента публикации.
SELECT 
	MIN(days_exposition)::INT AS мин_дней_экспозиции,
	MAX(days_exposition)::INT AS макс_дней_экспозиции,
	ROUND(AVG(days_exposition)::NUMERIC, 2) AS среднее_дней_экспозиции,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY days_exposition::INT) AS медиана_дней_экспозиции
FROM real_estate.advertisement;
--1.6.2 Найдем доля снятых с публикации объявлений, т.е. имеющих значение в поле days_exposition
--Около 86.55 % всех продаваемых объектов недвижимости могли быть проданы. 
--Если считать, что эти объекты проданы, то получается хорошая выборка данных для анализа.
SELECT
	объявлений_всего,
	снятые_объявления,
	ROUND(снятые_объявления::NUMERIC /объявлений_всего * 100, 2) AS процент_снятых_объявлений,
	объявлений_всего - снятые_объявления AS актуальные_объявления,
	ROUND((объявлений_всего - снятые_объявления)::NUMERIC / объявлений_всего * 100,
	2) AS процент_актуальных_объявлений						                                                  
FROM
	(
	SELECT 										--в подзапросе получим оконными функциями данные по всем полям
		COUNT(first_day_exposition) OVER () AS объявлений_всего,
		COUNT(days_exposition) OVER () AS снятые_объявления
	FROM
		real_estate.advertisement
	LIMIT 1) AS t;		
-- 1.7. Объявления Санкт-Петербурга
--рхив объявлений содержит объявления о продаже недвижимости в Санкт-Петербурге и Ленинградской области. 
--Поскольку это два разных субъекта, стоит оценить соотношение объявлений между ними. 
--Это поможет понять, стоит ли изучать такие рынки раздельно.
--66.47 % всех продаваемых объектов недвижимости находятся в пределах Санкт-Петербурга, что в целом ожидаемо.
--Соотношение между объявлениями в Санкт-Петербурге и Ленинградской области — примерно 66 к 34 или около 2 к 1. 
--Такое соотношение позволяет изучить объявления в двух субъектах раздельно и сопоставить результаты между 
--собой, хоть и объявлений в Санкт-Петербурге почти в два раза больше
WITH cte AS 
(
SELECT city,
COUNT(id) OVER () AS всего_объявлений,
COUNT(id) OVER (PARTITION BY city) AS объявлений_по_городу
FROM real_estate.flats
LEFT JOIN real_estate.city USING (city_id)
)
SELECT
	*,
	ROUND(объявлений_по_городу::NUMERIC / всего_объявлений * 100, 2) AS процент_спб,
	100 - ROUND(объявлений_по_городу::NUMERIC / всего_объявлений * 100, 2) AS процент_лен_область
FROM cte
WHERE city = 'Санкт-Петербург'
LIMIT 1;
--1.8 Стоимость квадратного метра
--Продаваемую недвижимость оценивают и по стоимости одного квадратного метра. 
--Это значение часто зависит от месторасположения недвижимости, общей площади и других характеристик. 
--Стоимость одного квадратного метра понадобится для решения аналитических задач, 
--поэтому убедимся, что в данных нет ошибок.
--1.8.1 Подсчитайте основные статистические показатели для значений стоимости одного квадратного метра
 -- минимальное, максимальное, среднее значения и медиану стоимости жилья.
--среднее значение близко к медианному, это может говорить или о том, что в данных нет выбросов или аномальных значений, 
--или они есть в части как низких значений, так и высоких. 
--Действительно, есть низкие значения — 112 рублей за квадратный метр, а есть и высокие — 1 907 500 рублей за квадратный метр. 
--Возможно, низкие значения представлены не в рублях, а в тысячах: уж слишком они низкие. 
--Высокие же значения вполне могут быть реальной стоимостью.
--Так как цель нашего анализа данных — получить общее представление о продажах недвижимости в регионах, то
--при изучении общих характеристик данных мы отфильтруем аномально высокие и низкие значения 
--и избежим их влияния на результат. 
--Продажу недвижимости со стоимостью 1 907 500 рублей за квадратный метр как раз можно рассматривать как аномальное событие.
WITH cte AS
( 
	SELECT 
		city_id,
		id,
		last_price,
		total_area,
		ROUND((last_price::REAL/total_area)::NUMERIC, 2) AS цена_за_квм
	FROM 
		real_estate.flats
	LEFT JOIN
		real_estate.advertisement USING (id)
 )
 SELECT 
 	MIN(цена_за_квм) AS мин_цена_за_квм,
 	MAX(цена_за_квм) AS макс_цена_за_квм,
 	ROUND(AVG(цена_за_квм)::NUMERIC, 2) AS ср_цена_за_квм,
 	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY цена_за_квм) AS медиана_цены_за_квм
 FROM cte
;

SELECT 
	MIN(days_exposition)::INT AS мин_дней_экспозиции,
	MAX(days_exposition)::INT AS макс_дней_экспозиции,
	ROUND(AVG(days_exposition)::NUMERIC, 2) AS среднее_дней_экспозиции,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY days_exposition::INT) AS медиана_дней_экспозиции
FROM real_estate.advertisement;

--1.9 Статистические показатели
--Проверим категориальные и количественные данные(минимальное и максимальное значения, среднее значение, медиану и 99 перцентил):

--1.9.1 По количественным данным: 
--общая площадь недвижимости,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
--количество комнат 
--балконов, 
--высота потолков, 
--этаж
--ВЫВОД Аномально высокие значения есть практически в каждом столбце, кроме этажа квартиры
--количество комнат, общая площадь, высота потолков и количество балконов содержат высокие значения, 
--которые редко встречаются среди широко распространённой недвижимости. 
--А вот 33 этаж — достаточно реальное значение, исходя из данных о высотности зданий в Спб.
-- Потолок в 100 метров кажется ошибкой в данных, особенно при значении 99 перцентиля, равным 3.83 м.
--Столь высокие значения негативно сказываются на средних значениях, поэтому их надо отфильтровать при основном анализе данных.
--Также смущает низкое значение высоты потолка — всего 1 метр,такое значение можно рассматривать как аномальное,
-- и его тоже стоит отфильтровать при исследовании, учитывая, что значение 1 перцентиля равно 2.5.
SELECT
	'общая площадь недвижимости' AS количественные_данные,
	MIN(total_area) AS мин_значение,
	MAX(total_area) AS макс_значение,
	ROUND(AVG(total_area)::NUMERIC, 2) AS ср_значение,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY total_area) AS медианное_значение,
	PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY total_area) AS персентиль_1_значения,
	PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY total_area) AS персентиль_99_значения
FROM real_estate.flats
UNION
SELECT
	'количество комнат' AS колич_данные,
	MIN(rooms) AS мин_значение,
	MAX(rooms) AS макс_значение,
	ROUND(AVG(rooms)::NUMERIC, 2) AS ср_значение,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY rooms) AS медианное_значение,
	PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY rooms) AS персентиль_1_значения,
	PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY rooms) AS персентиль_99_значения
FROM real_estate.flats
UNION
SELECT
	'балконов' AS колич_данные,
	MIN(balcony) AS мин_значение,
	MAX(balcony) AS макс_значение,
	ROUND(AVG(balcony)::NUMERIC, 2) AS ср_значение,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY balcony) AS медианное_значение,
	PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY balcony) AS персентиль_1_значения,
	PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY balcony) AS персентиль_99_значения
FROM real_estate.flats
UNION
SELECT
	'высота потолков' AS колич_данные,
	MIN(ceiling_height) AS мин_значение,
	MAX(ceiling_height) AS макс_значение,
	ROUND(AVG(ceiling_height)::NUMERIC, 2) AS ср_значение,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY ceiling_height) AS медианное_значение,
	PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY ceiling_height) AS персентиль_1_значения,
	PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY ceiling_height)AS персентиль_99_значения
FROM real_estate.flats
UNION
SELECT
	'этаж' AS колич_данные,
	MIN(floor) AS мин_значение,
	MAX(floor) AS макс_значение,
	ROUND(AVG(floor)::NUMERIC, 2) AS ср_значение,
	PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY floor) AS медианное_значение,
	PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY floor) AS персентиль_1_значения,
	PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY floor)AS персентиль_99_значения
FROM real_estate.flats;
--1.10 Общиц вывод по итогу исследования:
--мы познакомились с данными. С одной стороны, их хватает, чтобы решить задачи заказчика, 
--с другой — есть аномальные и нереальные значения. Таких значений немного, но лучше их отфильтровать, чтобы не работать с артефактами. 
--Для фильтрации данных в дальнейшем будем использовать обобщённое табличное выражение.
--например такой запрос Запрос выше отфильтрует аномальные значения и оставит id объявлений с корректными значениями:
--Получим отфильтрованные данные, если ссылаться на Номера объявлений в отфильтрованных данных, то
--можно использовать их при обращении к данным, как в основном запросе, здесь выведены актуальные объявления таблицы flats. 
--Используя id объявлений, можно аналогично фильтровать данные из таблицы advertisement.
--запрос:
-- Определим аномальные значения (выбросы) по значению перцентилей:
WITH limits AS (
    SELECT
        PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY total_area) AS total_area_limit,
        PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY rooms) AS rooms_limit,
        PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY balcony) AS balcony_limit,
        PERCENTILE_DISC(0.99) WITHIN GROUP (ORDER BY ceiling_height) AS ceiling_height_limit_h,
        PERCENTILE_DISC(0.01) WITHIN GROUP (ORDER BY ceiling_height) AS ceiling_height_limit_l
    FROM real_estate.flats
),
-- Найдём id объявлений, которые не содержат выбросы:
filtered_id AS(
    SELECT id    FROM real_estate.flats
    WHERE
        total_area < (SELECT total_area_limit FROM limits)
        AND rooms < (SELECT rooms_limit FROM limits)
        AND balcony < (SELECT balcony_limit FROM limits)
        AND ceiling_height < (SELECT ceiling_height_limit_h FROM limits)
        AND ceiling_height > (SELECT ceiling_height_limit_l FROM limits)
    )
-- Выведем объявления без выбросов:
SELECT *FROM real_estate.flats
WHERE id IN (SELECT * FROM filtered_id); 

--2. Решаем ad hoc задачи
--При решении оспользуем отфильтрованные от выбросов данные -- решение в отдельном скрипте.

